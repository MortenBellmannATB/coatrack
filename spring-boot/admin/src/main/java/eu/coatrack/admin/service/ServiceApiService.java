package eu.coatrack.admin.service;

import eu.coatrack.admin.controllers.admin.AdminConfig;
import eu.coatrack.admin.logic.CreateServiceAction;
import eu.coatrack.admin.model.repository.ApiKeyRepository;
import eu.coatrack.admin.model.repository.ServiceApiRepository;
import eu.coatrack.admin.model.vo.ServiceWizardForm;
import eu.coatrack.api.*;
import lombok.extern.slf4j.Slf4j;
import org.modelmapper.Conditions;
import org.modelmapper.ModelMapper;
import org.springframework.beans.factory.InitializingBean;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

import static eu.coatrack.api.ServiceAccessPaymentPolicy.WELL_DEFINED_PRICE;
import static org.modelmapper.convention.MatchingStrategies.STRICT;

@Slf4j
@Service
public class ServiceApiService  implements InitializingBean {

    @Autowired
    private ServiceApiRepository serviceApiRepository;

    @Autowired
    private CreateServiceAction createServiceAction;

    @Autowired
    private ApiKeyRepository apiKeyRepository;

    private static ModelMapper modelMapper;

    @Override
    public void afterPropertiesSet() {
        modelMapper = new ModelMapper();
        modelMapper.getConfiguration()
                .setMatchingStrategy(STRICT)
                .setPropertyCondition(Conditions.isNotNull());
    }

    public ServiceApi createServiceApi(ServiceWizardForm wizard, User authenticatedUser) {
        ServiceApi serviceApi = new ServiceApi();
        serviceApi.setName(wizard.getServiceName());
        serviceApi.setLocalUrl(wizard.getServiceUrl());

        if(wizard.isServiceForFree()) {
            serviceApi.setServiceAccessPaymentPolicy(ServiceAccessPaymentPolicy.FOR_FREE);
        } else if(wizard.isMonthlyCharged()) {
            serviceApi.setServiceAccessPaymentPolicy(ServiceAccessPaymentPolicy.MONTHLY_FEE);
            serviceApi.setMonthlyFee(Double.parseDouble(wizard.getServiceCost()));
        } else if(wizard.isChargedPerCall()) {
            serviceApi.setServiceAccessPaymentPolicy(ServiceAccessPaymentPolicy.WELL_DEFINED_PRICE);

            List<EntryPoint> entryPoints = new ArrayList<>();

            EntryPoint entryPoint = new EntryPoint();
            entryPoint.setHttpMethod("GET");
            entryPoint.setName("/");
            entryPoint.setPathPattern("/");
            entryPoint.setPricePerCall(Double.parseDouble(wizard.getServiceCost()));

            entryPoints.add(entryPoint);
            serviceApi.setEntryPoints(entryPoints);
        }

        serviceApi.setServiceAccessPermissionPolicy(ServiceAccessPermissionPolicy.PERMISSION_NECESSARY);
        serviceApi.setDescription("Generated by the getting started wizard");
        serviceApi.setOwner(authenticatedUser);

        createServiceAction.setUser(authenticatedUser);
        createServiceAction.setServiceApi(serviceApi);
        createServiceAction.execute();
        return createServiceAction.getServiceApi();
    }


    public List<String> getPayPerCallServicesIds(List<ServiceApi> serviceApis) {
        List<String> payPerCallServicesIds = new ArrayList<>();
        if (!serviceApis.isEmpty()) {
            payPerCallServicesIds = serviceApis.stream().filter(serviceApi -> serviceApi.getServiceAccessPaymentPolicy().equals(WELL_DEFINED_PRICE)).map(ServiceApi::getId).map(String::valueOf).collect(Collectors.toList());
        }
        return payPerCallServicesIds;
    }

    public List<User> getServiceConsumers(List<ServiceApi> servicesProvidedByUser) {
        return servicesProvidedByUser.stream()
                .flatMap(api -> api.getApiKeys().stream())
                .map(ApiKey::getUser)
                .distinct()
                .collect(Collectors.toList());
    }

    public ServiceApi findById(long id) {
        return serviceApiRepository.findById(id).orElse(null);
    }

    public List<ServiceApi> findFromActiveUser() {
       return serviceApiRepository.findByApiKeyList(apiKeyRepository.findByLoggedInAPIConsumer());
    }

    public List<ServiceApi> findByOwnerUsername(String name) {
        return serviceApiRepository.findByOwnerUsername(name);
    }

    public List<ServiceApi> findIfNotDeleted() {
        return serviceApiRepository.findByDeletedWhen(null);
    }

    public ServiceApiDTO findByServiceOwnerAndUriIdentifier(String uriIdentifier, String serviceOwnerUsername) {
        return toDTO(serviceApiRepository.findServiceApiByServiceOwnerAndUriIdentifier(serviceOwnerUsername, uriIdentifier));
    }

    public List<ServiceApiDTO> findByServiceOwner(String authenticatedUserName) {
        return toListOfDTOs(serviceApiRepository.findByOwnerUsername(authenticatedUserName));
    }

    public ServiceApi findServiceApiByServiceOwnerAndUriIdentifier(String serviceOwnerUsername, String uriIdentifier) {
        return serviceApiRepository.findServiceApiByServiceOwnerAndUriIdentifier(serviceOwnerUsername, uriIdentifier);
    }

    public ServiceApi getTestServiceForConsumerWizard(AdminConfig adminConfig) {
        // Getting the test service
        log.debug("trying to load test service for provider '{}' and uriIdentifier '{}'",
                adminConfig.getGettingStartedTestServiceProvider(),
                adminConfig.getGettingStartedTestServiceIdentifier()
        );

        ServiceApi testServiceApi = findServiceApiByServiceOwnerAndUriIdentifier(
                adminConfig.getGettingStartedTestServiceProvider(),
                adminConfig.getGettingStartedTestServiceIdentifier()
        );

        log.debug("test service loaded: {}", testServiceApi);
        return testServiceApi;
    }


    private static List<ServiceApiDTO> toListOfDTOs(List<ServiceApi> entity) {
        List<ServiceApiDTO> serviceApiDTOList = new ArrayList<>();

        for (ServiceApi singleEntity : entity) {
            serviceApiDTOList.add(modelMapper.map(singleEntity, ServiceApiDTO.class));
        }
        return serviceApiDTOList;
    }


    private static ServiceApiDTO toDTO(ServiceApi entity) {
        ServiceApiDTO serviceDTO = modelMapper.map(entity, ServiceApiDTO.class);
        serviceDTO.setServiceOwnerUsername(entity.getOwner().getUsername());
        return serviceDTO;
    }
}
